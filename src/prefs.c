/*****************************************************************************
 *                                                                           *
 *   MessyFront - prefs.c                                                    *
 *   (C) 2005 - 2007 Aaron Sebold                                            *
 *   Version 19                                                              *
 *                                                                           *
 *****************************************************************************
 *                                                                           *
 *   This program is free software; you can redistribute it and/or modify    *
 *   it under the terms of the GNU General Public License as published by    *
 *   the Free Software Foundation; either version 2 of the License, or       *
 *   (at your option) any later version.                                     *
 *                                                                           *
 *   This program is distributed in the hope that it will be useful,         *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of          *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the            *
 *   GNU General Public License for more details.                            *
 *                                                                           *
 *   You should have received a copy of the GNU General Public License       *
 *   along with this program; if not, write to the Free Software             *
 *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA *
 *                                                                           *
 *****************************************************************************/

#include "messy.h"

void save_prefs (PREFS *images)
{
	/* Save the user's choices in a preferences file.          */
	/* We aren't using GNOME's db for compatibility among OSs. */
	FILE *fp;																	/* File pointer for prefs file */
	gchar *prefsname, *varnames;							/* Name of file, data for file */
	
	/* Here is the file header for the file */
	char *header = "\
# This file was generated by MESSyFront - Please do not edit.\n\
# ----------------------------------------------------------------------\n\
# \"BIOS_IMAGE \" is the last BIOS image you used.\n\
# \"CARTRIDGE_IMAGE \" is the last cartridge image you used.\n\
# \"FLOPPY_IMAGES \" are the last floppy image(s) you used.\n\
# \"HDD_IMAGE \" is the last hard disk image you used.\n\
# \"MESS_EXECUTABLE \" is where MESS is located.\n\
# \"IMAGES_DIRECTORY \" is where your MESS images directory is located.\n\
# \"BIOS_DIRECTORY \" is where your MESS BIOS ROM images directory is located.\n\
# \"DISPLAY_COMMAND \" is for if you want the command to start MESS displayed.\n\
# ----------------------------------------------------------------------\n\n";

	/* Setup the path and name of the file */
	prefsname = g_strjoin (DIR_SEP, g_get_home_dir (), PREFS_FILENAME, NULL);
	
	/* Make sure everything is current in the struct */
	populate_object_from_fields (&images[0]);
	
	/* Create or overwrite the file */
	fp = fopen (prefsname, "w+");
	if (!fp)
	{
		/* Unable to create or overwrite the file */
		/* Temporary error report */
		fprintf (stderr, "MESSYFRONT: Unable to open the file, \"%s\"\n", prefsname);
		exit (EXIT_FAILURE);
	}
	
	fputs (header, fp);												/* Write the header to the file */
	
	/* Write the struct's data to the file */
	varnames = g_strjoin ("", KEY_BIOS_IMAGE, images->bios_image, "\n", NULL);
	varnames = g_strjoin ("", varnames, KEY_CARTRIDGE_IMAGE, images->cartridge_image, "\n", NULL);
	varnames = g_strjoin ("", varnames, KEY_FLOPPY_IMAGES, images->floppy_images, "\n", NULL);
	varnames = g_strjoin ("", varnames, KEY_HDD_IMAGE, images->hdd_image, "\n", NULL);
	varnames = g_strjoin ("", varnames, KEY_MESS_EXECUTABLE, images->mess_executable, "\n", NULL);
	varnames = g_strjoin ("", varnames, KEY_IMAGES_DIRECTORY, images->images_directory, "\n", NULL);
	varnames = g_strjoin ("", varnames, KEY_BIOS_DIRECTORY, images->bios_directory, "\n", NULL);
	if (images->display_command)
		varnames = g_strjoin ("", varnames, KEY_DISPLAY_COMMAND, "TRUE\n", NULL);
	else
		varnames = g_strjoin ("", varnames, KEY_DISPLAY_COMMAND, "FALSE\n", NULL);
	
	fputs (varnames, fp);											/* Write the data accumulated */
	
	fclose (fp);															/* Close the file */
}

void get_prefs_from_file (PREFS *images)
{
	/* Attains user preferences. */
	FILE *fp;																	/* File pointer for prefs file */
	char preline[MAX_LINE_CHARACTERS];				/* Where to put the current line */
	gchar *prefsname, *prefsline;							/* Name of file, Line of data */
	int x;
	
	/* Set up path and name of the file */
	prefsname = g_strjoin (DIR_SEP, g_get_home_dir (), PREFS_FILENAME, NULL);
	
	/* Check for file's existance */
	if (!g_file_test (prefsname, G_FILE_TEST_EXISTS))
	{
		/* The file doesn't exist */
		fprintf (stderr, "MESSYFRONT: Unable to open \"%s\"m will create on exit.\n", prefsname);
		return;
	}

	/* The file exists */
	fp = fopen (prefsname, "r");
	if (!fp)
	{
		/* Trouble opening the file */
		fprintf (stderr, "MESSYFRONT: Unable to open \"%s\" for reading!\n", prefsname);
		return;
	}
	
	/* Read and parse the file */
	x = 1;
	while (fgets (preline, MAX_LINE_CHARACTERS, fp))
	{
		prefsline = g_strjoin ("", preline, NULL);
		if (!parse_line (&images[0], prefsline))
		{
			/* Unable to parse the line */
			fprintf (stderr, "MESSYFRONT: Parse error in line %d of \"%s\"... Ignored.\n", x, prefsname);
		}
		
		x++;
	}
	
	populate_object_from_fields (&images[0]);	/* Sync object with fields */
	fclose (fp);															/* Close the file */			
}

gboolean parse_line (PREFS *images, gchar *prefsline)
{
	/* Parse a given line (prefsline). Return FALSE if unable to parse. */
	gboolean key_found = FALSE;
	int x;
	
	/* Do a quick check to make sure it's not a comment */
	if (g_ascii_isalpha (prefsline[0]))
	{
		/* Not a comment, attempt to parse it */
		for (x = 0; x < KEY_WORDS; x++)
		{
			key_found = FALSE;
			switch (x)
			{
				case 0:
					/* KEY_BIOS_IMAGE */
					key_found = parse_value (&images[0], KEY_BIOS_IMAGE, prefsline, WIDGET_BIOS_IMAGE);
					break;
				case 1:
					/* KEY_CARTRIDGE_IMAGE */
					key_found = parse_value (&images[0], KEY_CARTRIDGE_IMAGE, prefsline, WIDGET_CARTRIDGE_IMAGE);
					break;
				case 2:
					/* KEY_FLOPPY_IMAGES */
					key_found = parse_value (&images[0], KEY_FLOPPY_IMAGES, prefsline, WIDGET_FLOPPY_IMAGES);
					break;
				case 3:
					/* KEY_HDD_IMAGE */
					key_found = parse_value (&images[0], KEY_HDD_IMAGE, prefsline, WIDGET_HDD_IMAGE);
					break;
				case 4:
					/* KEY_MESS_EXECUTABLE */
					key_found = parse_value (&images[0], KEY_MESS_EXECUTABLE, prefsline, WIDGET_MESS_EXECUTABLE);
					break;
				case 5:
					/* KEY_IMAGES_DIRECTORY */
					key_found = parse_value (&images[0], KEY_IMAGES_DIRECTORY, prefsline, WIDGET_IMAGES_DIRECTORY);
					break;
				case 6:
					/* KEY_BIOS_DIRECTORY */
					key_found = parse_value (&images[0], KEY_BIOS_DIRECTORY, prefsline, WIDGET_BIOS_DIRECTORY);
					break;
				case 7:
					/* KEY_DISPLAY_COMMAND */
					key_found = parse_value (&images[0], KEY_DISPLAY_COMMAND, prefsline, WIDGET_DISPLAY_COMMAND);
					break;
				default:
					break;
			}
			
			/* If it found the key, break out of the loop */
			if (key_found)
				break;
		}
	
		/* No key was found. Return an error. */
		if (!key_found)
			return FALSE;

	}
	return TRUE;
}

gboolean parse_value (PREFS *images, char *key, char *prefsline, char *entry_place)
{
	/* Parse the given line. Check against keys,                */
	/* if it matches then copy value to the preferences object. */
	char current_key[KEY_WORDS_MAX_SIZE];			/* Left hand holder */
	char current_var[MAX_LINE_CHARACTERS];		/* Right hand holder */
	int key_length;														/* Length of current key */
	GtkWidget *entry_field;										/* Entry field to fill */
	
	/* Check to see if the keys match */
	key_length = strlen (key);								/* Get length of key */
	lefts (current_key, prefsline, key_length);
	if (strcmp (key, current_key))						/* Do they match? */
		return FALSE;														/* Keys don't match */
	
	/* The keys match, get the value of the key */
	rights (current_var, prefsline, strlen (prefsline) - key_length);
	lefts (current_var, current_var,  strlen (current_var) - 1);
	
	/* Check to see if the value is NULL */
	if (!strcmp ("", current_var))
		return TRUE;														/* The value was NULL */
	
	/* We have the value, put it in it's place */
	if (strcmp (KEY_DISPLAY_COMMAND, current_key))
	{
		/* This is for everything but the "Display Command" checkbox */
		entry_field = glade_xml_get_widget (images->xml, entry_place);
		gtk_entry_set_text (GTK_ENTRY (entry_field), current_var);
	}
	else
	{
		/* This is only for the "Display Command" checkbox */
		entry_field = glade_xml_get_widget (images->xml, entry_place);
		if (!strcmp (current_var, "TRUE"))
			gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (entry_field), TRUE);
		else
			gtk_toggle_button_set_active (GTK_TOGGLE_BUTTON (entry_field), FALSE);
	}
	
	return TRUE;
}
